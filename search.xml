<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[独立完成的Python爬虫项目]]></title>
    <url>%2F2018%2F02%2F03%2F%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E7%9A%84Python%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[基于爬取淘宝网商品信息爬虫实例，爬取当当网图书信息，读取用户输入的信息，进行搜索，翻页等功能的实现，主要用到了requests和re库，其实就是最常用的代码框架，项目主我的缺陷主要是对正则表达式不熟悉，不会使用增则表达式，对Python语法不熟悉，应加强这两个方面的应用！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsimport redef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: print('错误1')def pareHTML(html): try: book_price = re.findall(r'&amp;yen;(.*?)&lt;', html) book_name = re.findall(r'&lt;a title="(.*?)"', html) printHTMLMessage(book_price, book_name) # for i in range(len(list1)): # # price = eval(book_price[i].split(':')[1]) # # print(price) # # title = eval(book_name[i].split(':')[1]) # # print(title) # list1.append([book_price[i],book_name][i]) # print(list1) except: print('错误2')def printHTMLMessage(price, name): muban = "&#123;:1&#125;\t\t&#123;:6&#125;\t&#123;:15&#125;" print(muban.format('序号', '价格', '书名')) count = 1 for i in range(len(name)): print(muban.format(count, price[i], name[i])) count += 1if __name__ == '__main__': goods = input("请输入您要查询得商品：") deepth = (input("请输入查询的页数：")) list1 = [] for i in range(1, deepth + 1): try: url = 'http://search.dangdang.com/?key=' + goods + '&amp;act=input&amp;page_index=' + str(i) html = getHTMLText(url) pareHTML(html) except: continue]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取淘宝网商品信息]]></title>
    <url>%2F2018%2F02%2F02%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E7%BD%91%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[①代码分为三个模块，获得页面解析页面和输出有用信息，获得页面使用最基本的爬虫框架，解析页面用到了正则表达式的知识，输出信息主要就是format方法的使用②项目重点是parseHTML，首先分析淘宝搜索接口，然后查找有用信息在源代码中的位置，分析网址，实现翻页功能③判断main函数：使用if name == ‘main‘：并调用main()即可 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport redef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ''def parsePage(ilt,html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price,title]) except: print('出错啦')def printGoodList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:15&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count += 1 print(tplt.format(count,g[0],g[1]))if __name__ == '__main__': goods = '耳机' deepth = 5 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(deepth): try: utl = start_url + '&amp;s=' + str(44*i) html = getHTMLText(start_url) parsePage(infoList, html) except: continue printGoodList(infoList)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫-正则表达式]]></title>
    <url>%2F2018%2F02%2F02%2FPython%E7%88%AC%E8%99%AB-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。 正则表达式基本使用 基本使用规则 ： 表示其之的一个字符0次或者无限次扩展：abc* -&gt; ab,abc,abccc : 表示其之的一个字符1次或者无限次扩展：abc+ -&gt; abc,abcc,abccc? : 表示其之的一个字符0次或者1次扩展：abc? -&gt; ab,abc. : 任意一个字符| : 左右表达式任意一个 abc|def -&gt; abc或者def{m}：扩展其前面一个字符m次 ab{3}c -&gt; abbbc{m,n}：扩展其前面一个字符m次至n次 ab{3，4}c -&gt; abbbc，abbbbc^ : 表示匹配字符串的开头部分 ^abc -&gt; abcde,abco&amp; : 表示匹配字符串的结尾部分 abc&amp; -&gt; ertabc,sdfabc‘（）：分组标记\d : 数字，等价于[0-9]\w : 字符，等价于[A-Z0-9a-z_]原生字符串:不包含转义符前提：导入 re 包re库采用raw string类型来表示正则表达式比如r’text’ Re库主要功能函数 re.search()：在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 1234import rematch = re.search(r'[1-9]\d&#123;5&#125;','BIT 100081')if match: print(match.group(0)) search是从符合正则表达式的第一个位置匹配，返回match对象，但是match可能为空所以必须if一下 re.match()：从一个字符串的开始位置起匹配正则表达式，返回match对象 从开始位置匹配 re.findall()：搜索字符串，以列表类型返回全部能匹配的子串 re.split()：将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 返回的是匹配之后剩下的 re.finditer()：搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 返回的是迭代 re.sub()：在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符 123import rex = re.sub(r'[1-9]\d&#123;5&#125;','我爱吴嘉婕','BIT123456FEEG123456')print(x) BIT我爱吴嘉婕FEEG我爱吴嘉婕 match对象1.match.string:返回匹配的字符串是什me 123import rex = re.search(r'[1-9]\d&#123;5&#125;','BIT123456FEEG123456')print(x.string) match.re: 返回正则表达式 match.start()：符合匹配的初始位置 match.end()：符合匹配的结束位置 match.end(): 返回一个元组：包括起始位置和结束位置返回的就是BIT123456FEEG123456]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-爬取中国大学排名]]></title>
    <url>%2F2018%2F01%2F31%2FPython-%E2%80%9C%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[中国最好大学排名”是由上海软科教育信息咨询有限公司研制的中国国内大学排名。排名范围覆盖教育部公布的全国普通高等学校名单（截至2015年5月21日）中，1216所办学层次为本科的大学。2015年2月3日，“中国最好大学排名”由上海软科和腾讯教育频道在北京联合首次发布。2017年是该排名第三次发布。 爬取大学排名1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return '出错啦'def fillUnivList(ulist,html): soup = BeautifulSoup(html,'html.parser') for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string,tds[1].string,tds[2].string])def printUnivList(ulist,num): tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名","大学名称","总分",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2],chr(12288)))def main(): uinfo = [] url = 'http://www.zuihaodaxue.com/shengyuanzhiliangpaiming2017.html' html = getHTMLText(url) fillUnivList(uinfo,html) printUnivList(uinfo,30)main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫③]]></title>
    <url>%2F2018%2F01%2F31%2FPython%E7%88%AC%E8%99%AB%E2%91%A2%2F</url>
    <content type="text"><![CDATA[Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。 Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度 BeautifulSoup库的使用安装以管理员身份运行cmd，输入pip install BeautifunSoup4,然后在pycharm导入相应的模块就可以了 运行代码123456from bs4 import BeautifulSoupimport requestsr = requests.get("http://jw.qdu.edu.cn/homepage/index.do")demo = r.textsoup = BeautifulSoup(demo,"html.parser")print(soup.prettify()) soup = BeautifulSoup(demo,”html.parser”)的两个参数：第一个参数是html的一个格式第二个参数是html的解析器 基本元素BeautifulSoup库是解析，遍历，维护标签树的功能库 1.Tag2.Name3.Attributes4.Comment5.NavigableString 获得标签信息12345678#获得a标签tag = soup.a#获得a的名字，当然就是aprint（soup.a.name）#获得标签属性print（soup.a.attrs）#获得标签之间的字符串print(soup.a.string) .prettify()能够更加有好的显示html文件，包括换行符缩进等等 查找一个HTML页面a标签href后的内容12345678910from bs4 import BeautifulSoupimport requestsr = requests.get("https://www.icourse163.org/learn/BIT-1001870001?tid=1002236011")demo = r.textsoup = BeautifulSoup(demo,"html.parser")for link in soup.find_all('a'): if link.get('href') == None: pass else: print(link.get('href'))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫②]]></title>
    <url>%2F2018%2F01%2F31%2FPython%E7%88%AC%E8%99%AB%E2%91%A1%2F</url>
    <content type="text"><![CDATA[response.encoding和response.apparent_encoding的区别，response.encoding是python从url的header文件中读取的编码，如果服务器的header不存在cha’rset，则认为编码为ISO-8859-1,response.apparent_encoding是requests库从响应内容中分析出来的编码 HTTPhttp协议：超文本传输协议，是一个基于响应与请求模式的无状态的应用层协议请求与响应：用户发出请求，服务器响应 计算多次连续访问同一页面所需要的时间123456789101112def main(): url = 'https://www.icourse163.org/learn/BIT-1001870001?tid=1002236011#/learn/content?type=detail&amp;id=1002993601&amp;cid=1003503362' n = (int)(input("请输入需要爬取页面的次数： ")) t1 = time.time() for i in range(1,n+1): getHTMLText(url) print('第%d次爬取成功'%i) t2 = time.time() t = t2 - t1 print('连续访问%d个页面需要的时间是%f秒'% (n,t))main() 模拟浏览器发出请求12345678910import requestsurl = 'https://www.amazon.cn/gp/product/B0058XHR28?pf_rd_p=8e368709-9a2f-4695-abee-10147fab0c6e&amp;pf_rd_s=merchandised-search-7&amp;pf_rd_t=101&amp;pf_rd_i=1841388071&amp;pf_rd_m=A1AJ19PSB66TGU&amp;pf_rd_r=JKH9RF6AFN0YGT4GY92N&amp;ref=cn_ags_floor_hotasin_1841388071_mobile-1'try: kv = &#123;'User-Agent':'Mozilla/5.0'&#125; r = requests.get(url,timeout = 10,headers = kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.request.headers)except: print('失败') 通过修改头部信息，从而模拟浏览器访问页面 百度关键词搜索1234567891011import requestskv = &#123;'wd':'python'&#125;try: r = requests.get('https://www.baidu.com/s',params = kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.request.url) print(len(r.text))except: print('爬取失败') 从网上爬取图片并下载下来不规范版本： 1234567import requestspath = "D:/abc.jpg"url = 'http://imgsrc.baidu.com/forum/pic/item/e420a54bd11373f027775715a40f4bfbfaed0456.jpg'r = requests.get(url)# print(r.status_code)with open(path,'wb') as f: f.write(r.content) 规范： 1234567891011121314import requeststry: #图片地址 url = 'http://imgsrc.baidu.com/forum/pic/item/e420a54bd11373f027775715a40f4bfbfaed0456.jpg' #根目录 root = 'D:/' #储存的路径 path = root + url.split('/')[-1] r = requests.get(url) with open(path,'wb') as f: f.write(r.content)except: print("出错啦") ip地址查询123456789import requeststry: url = 'http://m.ip138.com/ip.asp?ip=' r =requests.get(url + '202.204.80.112') print(r.text[-500:])except: print("出错啦") 下载一个MOOC的视频123456789101112#爬一个慕课网的视频import requeststry: url = 'https://v.stu.126.net/mooc-video/nos/mp4/2017/02/28/1005855330_c19061df10ee4cd69496dba4292e9ea3_shd.mp4?ak=285ea3e4dadf82f0450503b24518d5679cdf68ccbb7c2011693b179b27153140698691431388c23472d118fc0d79340ceff6a55d15491982836e42383e13363eec6958477c8e90f2fc976eed060cb9b81e46d140b7b30f910299bee40b26a5c2d9e1e3c44585e5de5b539ccdbe8423a821b91261e44e538d2765af73aa008299a7f5cc498d43fe59a782bc973c30c066b767da1f870bc890754ea6567cb70ca9830b67d08aac63e1ac0c534090a89323f6fd9d4e9030d5d8cb0cb4b5fcb8e77c' r = requests.get(url) path = 'D:/123.mp4' with open(path,'wb') as f: f.write(r.content) print("下载完毕")except: print("XXX")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫①]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E7%88%AC%E8%99%AB%E2%91%A0%2F</url>
    <content type="text"><![CDATA[Python Request库入门 requests的安装requests库是Python第三方库最强大的爬虫库以管理员身份运行cmd，输入pip install requests即可，然后运行pycharm在setting相应位置install导入随便写一个Python程序 123456import requestsr = requests.get("http://www.baidu.com")print(r.status_code)print(type(r))r.encoding = 'utf-8'print(r.text) raise_for_status()方法调用raise_for_status()方法，如果r.status_code的返回值是200，则程序正常执行，如果不是两百，那么就会抛出一个requests.HTTPError异常 常用代码框架1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "产生异常"if __name__ == "__main__": url = "https://www.icourse163.org" print(getHTMLText(url))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础③]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E5%9F%BA%E7%A1%80%E2%91%A2%2F</url>
    <content type="text"><![CDATA[为了考虑为什么 python 不提供函数重载，首先我们要研究为什么需要提供函数重载。函数重载主要是为了解决两个问题。1。可变参数类型。2。可变参数个数。另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。 构造函数构造函数没有任何返回，也就是返回的是一个None new 的作用依照Python官方文档的说法，new方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。 假如我们需要一个永远都是正数的整数类型，通过集成int，我们可能会写出这样的代码。123456789class PositiveInteger(int): def __init__(self, value): super(PositiveInteger, self).__init__(self, abs(value))i = PositiveInteger(-3)print i 但运行后会发现，结果根本不是我们想的那样，我们任然得到了-3。这是因为对于int这种 不可变的对象，我们只有重载它的new方法才能起到自定义的作用。1234567891011这是修改后的代码：class PositiveInteger(int): def __new__(cls, value): return super(PositiveInteger, cls).__new__(cls, abs(value))i = PositiveInteger(-3)print i 通过重载new方法，我们实现了需要的功能。 del 的作用垃圾回收机制，当类的所有对象都delte之后，启用del方法 123456789class A: def __init__(self): print("I am __init__") def __del__(self): print("I am del")a = A()b = A()c = A() 运行结果123456I am __init__I am __init__I am __init__I am delI am delI am del]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F01%2F30%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表：是一种物理存储单元上非连续、非顺序的存储结构数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data; struct Node *pNext;&#125;Node,*pNode;pNode creat_list();void travel_list(pNode pHead);bool is_empty(pNode pHead);int length_list(pNode pHead);bool insert_list(pNode pHead,int index,int value);bool delete_list(pNode pHead,int index);void sort_list(pNode pHead);int get_list(pNode pHead,int index);int main()&#123; pNode pHead = NULL; pHead = creat_list(); printf("链表的长度是%d\n",length_list(pHead)); travel_list(pHead); printf("%d\n",get_list(pHead,1));&#125;pNode creat_list()&#123; int len; int value; pNode pHead = (pNode)malloc(sizeof(pNode)); pNode pTail = pHead; pTail-&gt;pNext = NULL; if(pHead == NULL) &#123; printf("内存分配失败"); exit(-1); &#125; else &#123; printf("len= "); scanf("%d",&amp;len); for(int i = 0; i &lt; len; i++) &#123; printf("%d",i+1); scanf("%d",&amp;value); pNode pNew = (pNode)malloc(sizeof(pNode)); if(pNew == NULL) &#123; printf("内存分配失败"); exit(-1); &#125; pNew-&gt;data = value; pTail-&gt;pNext = pNew; pNew-&gt;pNext = NULL; pTail = pNew; &#125; return pHead; &#125;&#125;void travel_list(pNode pHead)&#123; pNode p = pHead-&gt;pNext; while(p != NULL) &#123; printf("%d ",p-&gt;data); p = p-&gt;pNext; &#125; printf("\n");&#125;bool is_empty(pNode pHead)&#123; if(pHead-&gt;pNext == NULL) &#123; return true; &#125; return false;&#125;int length_list(pNode pHead)&#123; int count = 0; pNode p = pHead-&gt;pNext; while(p != NULL) &#123; count++; p = p-&gt;pNext; &#125; return count;&#125;bool insert_list(pNode pHead,int index,int value)&#123; int length = length_list(pHead); pNode p; p = pHead; if(index &gt; length+1 || index &lt; 1) &#123; printf("找不到\n"); &#125; else &#123; pNode pNew = (pNode)malloc(sizeof(pNode)); if(NULL == pNew) &#123; exit(-1); &#125; else &#123; while(index &gt; 1) &#123; p = p-&gt;pNext; index--; &#125; pNode q = p-&gt;pNext; pNew-&gt;data = value; pNew-&gt;pNext = q; p-&gt;pNext = pNew; &#125; &#125;&#125;bool delete_list(pNode pHead,int index)&#123; pNode p; p = pHead; int length = length_list(pHead); if(index &lt; 1 || index &gt; length) &#123; printf("找不到\n"); &#125; else if(index == 1) &#123; pHead-&gt;pNext = pHead-&gt;pNext-&gt;pNext; &#125; else &#123; while(index &gt; 1) &#123; p = p-&gt;pNext; index--; &#125; pNode q = p-&gt;pNext-&gt;pNext; p-&gt;pNext = q; &#125;&#125;void sort_list(pNode pHead)&#123; int i,j; int length = length_list(pHead); pNode q; for(i = 0; i &lt; length - 1; i++) &#123; for(j = 0,q = pHead-&gt;pNext; j &lt; length - 1; j++,q = q-&gt;pNext) &#123; if(q-&gt;data &gt; q-&gt;pNext-&gt;data) &#123; int temp = q-&gt;data; q-&gt;data = q-&gt;pNext-&gt;data; q-&gt;pNext-&gt;data = temp; &#125; &#125; &#125;&#125;int get_list(pNode pHead,int index)&#123; pNode p = pHead; while(index &gt;0) &#123; p = p-&gt;pNext; index--; &#125; return p-&gt;data;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础②]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E5%9F%BA%E7%A1%80%E2%91%A1%2F</url>
    <content type="text"><![CDATA[Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。 如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。 接下来我们先来简单的了解下面向对象的一些基本特征。 类和对象视频出处类和变量 类的创建和类的实例化一般来说，类名都是大写 12345678910111213class Dog: #属性 color = 'green' weight = '10' def climb(self): print('小狗跳啊跳')#实例化对象a_dog = Dog()#调用方法a_dog.climb() self是什么类似于C++的this指针 123class Ball: def setName(self,name): self.name = name self在类中的方法中是必须的！ 类的继承1234567891011class MyList(list): passlist2 = MyList()list2.append(9)list2.append(1)list2.append(88)list2.sort()print(list2) 多态12345678910class A: def fun(self): print('我是A')class B: def fun(self): print('我是B')a = A()b = B()a.fun()b.fun() 类的构造方法12def __init__(self): print('') 和Java不一样的是，以下代码会报错 1234class Ball: def __init__(self,name): print('')a = Ball() 因为没有穿进去name参数，而Python不会新建一个无参构造器 公有和私有将类中的属性变为私有只需要在前面加上__即可1234class Person(): __name = '小甲鱼'p = Person()print(p.__name) 由于__name是私有属性，类的外部无法访问,编译出错1234Traceback (most recent call last): File "D:/大二学习资料/Python/HelloWorld.py", line 95, in &lt;module&gt; print(p.__name)AttributeError: 'Person' object has no attribute '__name' 可以通过以下代码访问123456class Person(): __name = '小甲鱼' def getname(self): return self.__namep = Person()print(p.getname()) 但是Python的私有机制是“伪私有”，实际上就是Pyton将变量名改成了_类名__变量名通过一下代码就可以访问私有变量123456class Person(): __name = '小甲鱼' def getname(self): return self.__namep = Person()print(p._Person__name)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础①]]></title>
    <url>%2F2018%2F01%2F29%2FPython%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前面的非常基础的就不写在博客里异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况下，在Python无法正常处理程序时就会发生一个异常。 异常是Python对象，表示一个错误。 当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 Python中的异常处理常见形式123456789101112131415try: #文件错误 f = open('abc.txt') print(f) f.close() #数值错误 int('abc') #类型错误 sum = 1 + '1'except OSError as reason: print(reason)except TypeError as reason: print(reason)except ValueError as reason: print(reason) 当然也可以使用多个异常在一条语句： 1234567891011try: #文件错误 f = open('abc.txt') print(f) f.close() #数值错误 int('abc') #类型错误 sum = 1 + '1'except (OSError,TypeError) as reason: print(reason) finally语句和Java一样，finally语句是无论如何都要执行的语句： 1234567try: #文件错误 f = open('abc.txt','w')except OSError as reason: print(str(reason))finally: f.close() raise关键字raise和Java中的throws关键字一样，都是抛出一个异常的意思 1raise ZeroDivisionError('除数为0') With关键字12345678try: f = open('我是谁.txt','w') for each_line in f: print(each_line)except OSError as reason: print(reason)finally: f.close() 如果文件不存在会创建一个”我是谁.txt”文件，但是会抛出一个noreadable异常关闭文件的时候只会关闭一个不存在的文件。这时候就可以使用with关键字监视文件f，会自动关闭文件 123456try: with open('我是谁.txt','w') as f: for each_line in f: print(each_line)except OSError as reason: print(reason) with关键字常用于文件的操作！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中string字符串的比较]]></title>
    <url>%2F2018%2F01%2F28%2FC-%E4%B8%ADstring%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[通过C++内置的sort加上自定义cmp函数可以实现string字符串的比较，因为C++string重载了一些运算符，可以直接比较大小。 123456789bool cmp(char a,char b)&#123; return a &gt; b;&#125;bool cmp1(string a,string b)&#123; return a &gt; b;&#125; cin，coutC++涉及string一定要用到cin，cout输入和输出其包含在 #include头文件中 1cout &lt;&lt; endl 代表换行 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std;bool cmp(char a,char b)&#123; return a &gt; b;&#125;bool cmp1(string a,string b)&#123; return a &gt; b;&#125;int main()&#123; string s1 = "4321"; sort(s1.begin(),s1.end()); cout &lt;&lt; s1 &lt;&lt; endl; sort(s1.begin(),s1.end(),cmp); cout &lt;&lt; s1 &lt;&lt;endl; string s[3]; s[0] = "123"; s[1] = "234"; s[2] = "211"; sort(s,s+3); for(int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; s[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; sort(s,s+3,cmp1); for(int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; s[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;/*12344321123 211 234234 211 123*/]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1047. 编程团体赛(20)]]></title>
    <url>%2F2018%2F01%2F28%2F1047-%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B-20%2F</url>
    <content type="text"><![CDATA[编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。 现给定所有队员的比赛成绩，请你编写程序找出冠军队。 输入格式： 输入第一行给出一个正整数N（&lt;=10000），即所有参赛队员总数。随后N行，每行给出一位队员的成绩，格式为：“队伍编号-队员编号 成绩”，其中“队伍编号”为1到1000的正整数，“队员编号”为1到10的正整数，“成绩”为0到100的整数。 输出格式： 在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。 题目团体编程赛 注意1scanf("%d-%d%d",&amp;team,&amp;value,&amp;grade); 如果用户输入固定，可以直接在scanf中写出来. 代码12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int a[10000]; memset(a,0,sizeof(a)); int n,value,team,grade; int max_team,max_grade = -1; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d-%d%d",&amp;team,&amp;value,&amp;grade); a[team] += grade; if(a[team] &gt; max_grade) &#123; max_grade = a[team]; max_team = team; &#125; &#125; printf("%d %d",max_team,max_grade);&#125;]]></content>
      <categories>
        <category>PAT-Basic-Level</category>
      </categories>
      <tags>
        <tag>PAT-Basic-Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数]]></title>
    <url>%2F2018%2F01%2F28%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b），同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。与最大公约数相对应的概念是最小公倍数，a，b的最小公倍数记为[a，b]。 公式gcd(a,b) = gcd(b,a%b);思维方式 题目最大公约数 代码12345678910111213141516#include&lt;stdio.h&gt;int gcd(int a,int b)&#123; if(b == 0) return a; else return gcd(b,a%b);&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); printf("最大公约数为：%d",gcd(n,m));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1019. 数字黑洞 (20)]]></title>
    <url>%2F2018%2F01%2F28%2F1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E-20%2F</url>
    <content type="text"><![CDATA[1.sort排序时，第一个元素是排序元素的首地址，第二个元素是排序元素的地址的下一个位置，比如排序前三个元素应该是什么2.如果想输出的是四位整数，应该怎么做 题目数字黑洞 题解有以下两个地方值得注意1.sort排序时，第一个元素是排序元素的首地址，第二个元素是排序元素的地址的下一个位置，比如排序前三个元素应该是s 1sort(a,a+3); 2.如果想输出的是四位整数，应该是 1printf("%04d",result); 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int a[10];//递减bool cmp(int a,int b)&#123; return a &gt; b;&#125;void to_array(int n)&#123; for(int i = 1; i &lt;= 4; i++) &#123; a[i] = n%10; n = n/10; &#125;&#125;int main()&#123; int n; int max,min,result; scanf("%d",&amp;n); to_array(n); while(true) &#123; sort(a+1,a+5,cmp); min = a[4]*1000 + a[3]*100 + a[2]*10 + a[1]; sort(a+1,a+5); max = a[4]*1000 + a[3]*100 + a[2]*10 + a[1]; result = max -min; printf("%04d - %04d = %04d\n",max,min,result); if(result == 0 || result == 6174) break; else &#123; to_array(result); &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT-Basic-Level</category>
      </categories>
      <tags>
        <tag>PAT-Basic-Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2018%2F01%2F28%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[①二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列②首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 二分查找代码就不解释了，很简单123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int x; scanf("%d",&amp;x); int mid,left,right; int a[20] = &#123;1,2,3,4,5,6,7,8,10,15,79&#125;; left = 0; right = 10; while(left &lt;= right) &#123; mid = (left + right)/2; if(x == a[mid]) &#123; printf("%d",mid+1); break; &#125; else if(a[mid] &gt; x) &#123; right = mid - 1; &#125; else if(a[mid] &lt; x) &#123; left = mid + 1; &#125; else &#123; printf("没找到此数"); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更新博客基本步骤]]></title>
    <url>%2F2018%2F01%2F28%2FHexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作 新建文章1$ hexo new &quot;文章名&quot; 更新操作12$ hexo g$ hexo d 或者1$ hexo d -g 添加tags或者categories直接在md文件里添加即可，不必新建一个tags或者categories]]></content>
      <categories>
        <category>Hexo学习</category>
      </categories>
      <tags>
        <tag>Hexo学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归思想]]></title>
    <url>%2F2018%2F01%2F28%2F%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回 递归思想定义通过反复调用自己从而实现递归的过程 求n！n！就是典型的递归思想 代码实现123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;int dg(int n)&#123; if(n == 1) return 1; else return n*dg(n-1);&#125;int main()&#123; int n; scanf("%d",&amp;n); printf("%d",dg(n));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间贪心算法]]></title>
    <url>%2F2018%2F01%2F27%2F%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[找出有限集合中，不重合区间的最大的个数 算法将得到的区间按照区间右端点从小到小排序，然后从第一组开始，一次判断是否符合条件，若符合，count++，最后输出count即可，仍需注意，如果count如果从1开始计数，排序后的数组应该从第二个开始对应。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x; int y;&#125;I[1000];bool cmp(node a,node b)&#123; if(a.y != b.y) &#123; return a.y &lt; b.y; &#125;&#125;int main()&#123; //区间个数 int count = 1; int n; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d %d",&amp;I[i].x,&amp;I[i].y); &#125; sort(I+1,I+n+1,cmp); for(int i = 2; i &lt;= n; i++) &#123; if(I[i].x &lt; I[i-1].y) &#123; &#125; else &#123; count++; &#125; &#125; printf("%d",count); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2018%2F01%2F27%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储），但是把最后一个数据元素的尾指针指向了首位结点） 理解通过线性表，了解了C++中具体的指针和引用的使用方法，加深了对结构体的理解 线性表的具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//线性表的简单实现#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;//exit(-1)struct Arr&#123; //数组第一个元素的指针 int *psd; int max; int cnt;&#125;;//功能列表void init(struct Arr *parr,int length);bool append(struct Arr *parr,int value);bool insert(struct Arr *parr,int index,int value);bool deletes(struct Arr *parr,int index);void get(struct Arr *arr,int index);bool is_empty(struct Arr *parr);bool is_full(struct Arr *parr);void show(struct Arr *parr);void sort(struct Arr *parr);int main()&#123; int length = 10; struct Arr arr; init(&amp;arr,length); return 0;&#125;//*arr赋值给parrvoid init(struct Arr *parr,int length)&#123; parr-&gt;psd = (int*)malloc(sizeof(int) * length); if(NULL == parr-&gt;psd) &#123; printf("内存分配失败!\n"); exit(-1); &#125; else &#123; parr-&gt;max = length; parr-&gt;cnt = 0; &#125;&#125;bool is_empty(struct Arr *parr)&#123; if(parr-&gt;cnt == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;void show(struct Arr *parr)&#123; if(is_empty(parr)) &#123; printf("数组为空！\n"); &#125; else &#123; printf("数组为："); for(int i = 0; i &lt; parr-&gt;cnt; i++) &#123; printf("%d ",parr-&gt;psd[i]); &#125; printf("\n"); &#125;&#125;bool is_full(struct Arr *parr)&#123; if(parr-&gt;cnt == parr-&gt;max) &#123; return true; &#125; else return false;&#125;bool append(struct Arr *parr,int value)&#123; if(is_full(parr)) &#123; printf("数组已满,数值%d插入失败\n",value); return false; &#125; else &#123; printf("数值%d插入成功\n",value); parr-&gt;psd[parr-&gt;cnt] = value; (parr-&gt;cnt)++; return true; &#125;&#125;bool insert(struct Arr *parr,int index,int value)&#123; if(is_full(parr)) &#123; printf("数组已满，数值%d无法插入",value); return false; &#125; else if(index &lt; 1 || index &gt; parr-&gt;cnt + 1) &#123; printf("数值%d插入失败\n",value); return false; &#125; else &#123; printf("数值%d插入成功\n",value); for(int i = parr-&gt;cnt-1; i &gt;= index-1; i--) &#123; parr-&gt;psd[i+1] = parr-&gt;psd[i]; &#125; parr-&gt;psd[index-1] = value; parr-&gt;cnt++; return true; &#125;&#125;bool deletes(struct Arr *parr,int index)&#123; if(is_empty(parr)) &#123; printf("数组已为空，不可删除元素\n"); return false; &#125; else if(index &gt; parr-&gt;cnt) &#123; printf("此位无元素，不可删除\n"); return false; &#125; else &#123; printf("第%d个元素删除成功\n",index); for(int i = index; i &lt;= parr-&gt;psd[index-1]; i++) &#123; parr-&gt;psd[index-1] = parr-&gt;psd[index]; &#125; parr-&gt;cnt--; return true; &#125;&#125;void get(struct Arr *parr,int index)&#123; if(parr-&gt;cnt &gt; index) &#123; printf("此位置没有元素"); &#125; else &#123; printf("此位置的元素为：%d\n",parr-&gt;psd[index-1]); &#125;&#125;void sort(struct Arr *parr)&#123; for(int i = 0; i &lt; parr-&gt;cnt; i++) &#123; for(int j = 0; j &lt; parr-&gt;cnt-1; j++) &#123; if(parr-&gt;psd[j] &gt; parr-&gt;psd[j+1]) &#123; int temp; temp = parr-&gt;psd[j]; parr-&gt;psd[j] = parr-&gt;psd[j+1]; parr-&gt;psd[j+1] = temp; &#125; &#125; &#125; printf("排序后"); void show(struct Arr *parr);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Sort排序]]></title>
    <url>%2F2017%2F11%2F14%2FJava%E4%B8%AD%E7%9A%84Sort%E6%8E%92%E5%BA%8F-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[C++中提供了sort函数，可以让程序员轻松地调用排序算法，JAVA中也有相应的函数。由于要用到sort中的第二个参数，这个参数是一个类，所以应该用Integer，而不是int。可以使用Interger.intvalue()获得其中int的值 下面a是int型数组，b是Interger型的数组，a拷贝到b中，方便从大到小排序。capare中返回值是1表示需要交换。 Java中的Sort排序：1.定义排序类2.重写compare方法3.调用Collections中的sort方法 1234567891011121314151617181920212223242526272829303132333435363738394041package Collection;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.Comparator;import java.util.Scanner;class Mycomp implements Comparator&#123; public int compare(Object o1,Object o2) &#123; Integer i1 = (Integer)o1; Integer i2 = (Integer)o2; return i2.intValue() - i1.intValue(); &#125;&#125;public class Sort_Way&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); ArrayList a1 = new ArrayList(); for(int i = 1; i &lt;= 5; i++) &#123; int j = scanner.nextInt(); a1.add(j); &#125; //排序前 System.out.println(a1); //排序后 Collections.sort(a1,new Mycomp()); System.out.println(a1); &#125;&#125; 未完待续~~]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclpise快捷键]]></title>
    <url>%2F2017%2F11%2F12%2FEclpise%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。Eclipse 常用快捷键Eclipse 的很多操作都提供了快捷键功能，我们可以通过键盘就能很好的控制 Eclipse 各个功能： 使用快捷键关联菜单或菜单项使用快捷键关联对话窗口或视图或编辑器使用快捷键关联工具条上的功能按钮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Ctrl+1 快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如import类、try catch包围等）Ctrl+Shift+F 格式化当前代码Ctrl+Shift+M 添加类的import导入Ctrl+Shift+O 组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用）Ctrl+Y 重做（与撤销Ctrl+Z相反）Alt+/ 内容辅助（帮你省了多少次键盘敲打，太常用了）Ctrl+D 删除当前行或者多行Alt+↓ 当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了）Alt+↑ 当前行和上面一行交互位置（同上）Ctrl+Alt+↓ 复制当前行到下一行（复制增加）Ctrl+Alt+↑ 复制当前行到上一行（复制增加）Shift+Enter 在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）Ctrl+/ 注释当前行,再按则取消注释选择Alt+Shift+↑ 选择封装元素Alt+Shift+← 选择上一个元素Alt+Shift+→ 选择下一个元素Shift+← 从光标处开始往左选择字符Shift+→ 从光标处开始往右选择字符Ctrl+Shift+← 选中光标左边的单词Ctrl+Shift+→ 选中光标又边的单词移动Ctrl+← 光标移到左边单词的开头，相当于vim的bCtrl+→ 光标移到右边单词的末尾，相当于vim的e搜索Ctrl+K 参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word）Ctrl+Shift+K 参照选中的Word快速定位到上一个Ctrl+J 正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建）Ctrl+Shift+J 反向增量查找（和上条相同,只不过是从后往前查）Ctrl+Shift+U 列出所有包含字符串的行Ctrl+H 打开搜索对话框Ctrl+G 工作区中的声明Ctrl+Shift+G 工作区中的引用导航Ctrl+Shift+T 搜索类（包括工程和关联的第三jar包）Ctrl+Shift+R 搜索工程中的文件Ctrl+E 快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）F4 打开类型层次结构F3 跳转到声明处Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面（当然是针对上面那条来说了）Ctrl+PageUp/PageDown 在编辑器中，切换已经打开的文件调试F5 单步跳入F6 单步跳过F7 单步返回F8 继续Ctrl+Shift+D 显示变量的值Ctrl+Shift+B 在当前行设置或者去掉断点Ctrl+R 运行至行(超好用，可以节省好多的断点)重构（一般重构的快捷键都是Alt+Shift开头的了）Alt+Shift+R 重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力）Alt+Shift+M 把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）Alt+Shift+C 修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定）Alt+Shift+L 抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）Alt+Shift+F 把Class中的local变量变为field变量 （比较实用的功能）Alt+Shift+I 合并变量（可能这样说有点不妥Inline）Alt+Shift+V 移动函数和变量（不怎么常用）Alt+Shift+Z 重构的后悔药（Undo）其他Alt+Enter 显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径Ctrl+↑ 文本编辑器 上滚行Ctrl+↓ 文本编辑器 下滚行Ctrl+M 最大化当前的Edit或View （再按则反之）Ctrl+O 快速显示 OutLine（不开Outline窗口的同学，这个快捷键是必不可少的）Ctrl+T 快速显示当前类的继承结构Ctrl+W 关闭当前Editer（windows下关闭打开的对话框也是这个，还有qq、旺旺、浏览器等都是）Ctrl+L 文本编辑器 转至行F2 显示工具提示描述]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection中的遍历]]></title>
    <url>%2F2017%2F11%2F09%2FCollection%E4%B8%AD%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[collection：来源于Java.util包，是非常实用常用的数据结构!!!!!字面意思就是容器。具体的继承实现关系如下图，先整体有个印象，再依次介绍各个部分的方法，注意事项，以及应用场景。面试经常问到：1.Q:ArrayList和Vector有什么区别？HashMap和HashTable有什么区别？ A:Vector和HashTable是线程同步的（synchronized）。性能上，ArrayList和HashMap分别比Vector和Hashtable要好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * Collection集合 * 2017/11/9 */package Collection;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;public class CollectionTest &#123; public static void main(String[] args) &#123; /* * ArraryList集合 * 按照输入顺序排列 */ Collection c = new ArrayList(); c.add("MrsW6"); c.add(45); c.add(789); System.out.println(c); //HashSet集合 Collection book = new HashSet(); book.add(123); book.add("小王"); System.out.println(book); //遍历集合 //1.利用foreach循环遍历集合 for(Object a : c) &#123; System.out.println(a); &#125; //利用Java8增强的Iterator遍历集合 //迭代器 Iterator iterator = c.iterator(); while(iterator.hasNext()) &#123; Object re = iterator.next(); System.out.println(re); &#125; &#125;&#125; Iterator迭代器：123boolean hasNest():集合元素没有被迭代完，返回trueObjext next():返回集合里的下一个元素void remov(): 删除上一次next掉的元素]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2017%2F11%2F08%2FGit-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[概念，git，解决版本控制的问题的操作体系，基本形式是分布式 概念，提交，一个保存的工作状态，整个git的基本元素，类似于还原点的作用，可以查到版本号 概念，工作区，暂存区，master分支，head指针。基本是工作区和版本库，版本库包含暂存区和提交区（分支区），工作区是工作文件夹，暂存区是作为提交缓存以及确保不会提交错用的，master是默认的分支，head指针指向当前分支。指针结果类似c++。所有看起来复杂的操作，背后的逻辑都是这4个概念 技巧，status查看状态时会给出操作提示 概念，分支，本质是一种提交, 准确来说应该是提交区，基于分支概念，修复bug开发feature的时候都应该应用这种手段。另一方面，基于分支概念，开发的基本模式，master稳定发布版本，dev提交开发版，其他另开支线 git本质上是用于版本控制，准确的讲，分布式版本控制管理系统 分布式：每台机器都又独立的资源，有一个总服务器强调用于资源交换更新 集中式：资源都处于一个服务器中，每台机器连接后操作 创建版本库123456$ mkdir learngit 创建文件夹$ cd learngit 进入$ pwd 查看目录$ git init 初始化为版本库$ git add readme.txt 添加的暂存区$ git commit -m &quot;wrote a readme file&quot; 提交 时光穿梭基本操作12$ git status 查看状态（工作区和暂存区）$ git diff 查看修改（对比工作区和提交中） 版本回退123456$ git log 查看日志$ git reflog 查看未来日记$ git log --pretty=oneline 简化日志两种回退$ git reset --hard HEAD^ 上一个版本 ^^和~100$ git reset --hard 3628164 撤销修改123$ cat readme.txt 查看$ git checkout -- readme.txt 恢复，原理是和版本库同步$ git reset HEAD readme.txt 取消添加到暂存区 删除文件1234$ rm test.txt 文件管理器中删除$ git rm test.txt 添加删除操作到暂存区$ git commit -m &quot;remove test.txt&quot; 提交$ git checkout -- test.txt 用于取消删除，原理是和版本库同步 远程仓库概念.分支本质上一种提交,master指针和其他指针操作,方便于开发来回操作的一种体系.要注意,本质上区别于平行世界. 分支的基本Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突: 两条分支都修改merge后提示错误，只需要再进入文件，按提示修改后提交即可 文件中是这样的 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 分支管理策略：形成一套开发体系基本操作是基于合并的时候保存该分支的提交 查看分支图：git log --graph --pretty=oneline --abbrev-commit 合并保存（禁用fast forwardgit merge --no-ff -m &quot;merge with no-ff&quot; dev 遇到bug需要开发新feature：保存当前分支，切取修bug保存现场 git status 查看stash git status list 恢复现场两种 应用某一个git stash apply stash@{0},删除第一个（0）git stash drop 应用并删除git stash pop 远程相关123456789$ git remote -v 查看连接 -v为详细信息参数$ git push origin master 推送分支克隆到本地$ git clone git@github.com:michaelliao/learngit.git设置修改人和邮箱$ git config --global user.name &quot;Your Name&quot; 设置修改人 --global为全局参数$ git config --global user.email &quot;email@example.com&quot; 设置邮箱查看修改其他分支$ git checkout -b dev origin/dev 解决多人修改同一个分支的问题 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 标签本质同样是提交，和分支类似，只不过分支可以移动，标签不可以 1234567891011添加$ git tag v1.0 当前指针标签$ git tag v0.9 6224937 版本号标签$ git show v0.9 详情$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a -s用私钥签名一个标签安装gpg（GnuPG）删除$ git tag -d v0.1 本地git push origin :refs/tags/&lt;tagname&gt; 远程（需要先删本地）推送$ git push origin v1.0 推送一个$ git push origin --tags 推送全部]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更新博客及命令总结]]></title>
    <url>%2F2017%2F11%2F06%2FpostHexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很多人比如我的博客都是通过使用GitHub pages和hexo搭建的，在搭建过程中，因为操作我总是记不住，所以搭建了好久才搭建成果，因此我特意花了一些时间把更新博客的流程和一些命令的功能进行了总结。 hexo更新博客：首先进入hexo目录下：每次对博客进行操作，最后的步骤一定记住在命令行中输入： 1231.1hexo clean #清除缓存2.2.hexo g #生成静态网页 3.3.hexo d #部署到GitHub 在终端执行前可以用hexo s– debug，然后本地访问http://localhost:4000预览效果。若本地访问失败，有可能是因为4000端口被占用，可以输入hexo server -p 4001操作，将端口临时切换为4001，这时访问http：//localhost：4001,便可进行查看。如果还不行，那就继续切换端口。 命令总结 ： 3.1 每次部署的步骤，可按以下三步来进行。 123$ hexo clean$ hexo generate$ hexo deploy 3.2 本地调试 12$ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试 3.3 常用命令/复合命令/命令简写 12345678910111213$hexo new “postName” #新建文章$hexo new page “pageName” #新建页面$hexo generate #生成静态页面至public目录$hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）$hexo deploy #将.deploy目录部署到GitHub$hexo help # 查看帮助$hexo version #查看Hexo的版本$hexo deploy -g #生成加部署$hexo server -g #生成加预览$hexo n == hexo new$hexo g == hexo generate$hexo s == hexo server$hexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo学习</category>
      </categories>
      <tags>
        <tag>Hexo学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[折腾了三天了，各种百度，终于终于把这个博客搭建好了，啊阿阿阿阿阿真的折腾哈哈哈，不过还是特别特别开心的 一 为什么搭建这个博客？原因有二吧，第一个是真么不喜欢CSDN和博客园，另外也觉得自己应该接触一下github和各种命令行了！ 二 自己选择选软工程这个专业也算是自己的一份执着吧，去年暑假跟家人各种信誓旦旦好好学习，但是自己还是没有做到，整个大一一年，睡觉弹琴，各种玩各种嗨，认识了很多人，专业课和一些基础课程都拉下了，也挂了科，其实也挺后悔的，或许我属于那种想变的很优秀但是却不愿意付出努力的那种人吧 三 我说过，我是一个想变的优秀但是不愿意改变的人，今年六月份，学校的实验室开始纳新了，当时我觉得那是一个改变现状的好机会，于是我努力了两个月，把C语言一通学，各种刷题，然后磕磕绊绊进了我们院的俩实验室，再后来误打误撞考进了我们学校的ACM集训队，暑假回家一个周，剩下的时间都在实验室泡着，天天刷题，说实话，我不是很聪明的那种人，集训的那两个月，我真的特别特别痛苦，想女朋友，想家人，每天面对形形色色的题，真的有一种绝望的感觉，知道那天晚上我明白了，或许我不适合程序竞赛吧！ 四 虽然说在集训队的这两个月我很痛苦，但是很充实，也和我们学校很多优秀的人一起学习，当时非常迷茫，现在只能说是比较迷茫吧哈哈哈哈，但是，知道我对未来有了目标，大二了，我感觉到了，我确实变化了，但是还不够，我希望自己变的更优秀！加油吧！ 五嗯，不说了，希望自己能用博客记录自己的编程之路！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
