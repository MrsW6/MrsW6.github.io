<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT-Basic-Level题解及代码]]></title>
    <url>%2F2018%2F04%2F12%2FPAT-Basic-Level%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[df sdf fsd fds fs sdf fds fsd fsd fd ID Title 题目 C/C++代码 备注 1005 继续(3n+1)猜想 查看题目 查看题解 模拟 1007 素数对猜想 查看题目 查看题解 素数 1012 数字分类 查看题目 查看题解 素数 1013 数素数 查看题目 查看题解 素数 1014 福尔摩斯的约会 查看题目 查看题解 字符串 1018 锤子剪刀布 查看题目 查看题解 模拟]]></content>
      <categories>
        <category>PAT-Basic-Level</category>
      </categories>
      <tags>
        <tag>PAT-Basic-Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南京之行]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8D%97%E4%BA%AC%E4%B9%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[一 我的文笔不好，不会说话。也从不写日记，但是，我还是想记录下来这次旅行。 二 怀着向往来到这座心仪的城市，我真的好喜欢南京。点点滴滴。南京的地铁，不新不旧，和青岛的不同，它散发出来的是古城的气息。地铁很宽，坐上去很舒服，嗯，我喜欢这种感觉。 南方的清明节还是和北方不太一样，去年济南的清明，艳阳高照，穿着羽绒服过去的我们还被滴滴司机嘲笑了一番。 南京和济南不同，刚到的第一天，就下起了大雨，幸亏民宿的房东开车接过来我们，不然可能···哈哈哈 我们住的地方在东南大学成贤学院附近，浦口区，距离市中心非常远，但是好在南京的地铁非常发达，所以我们出行也十分方便。 在民宿安置好了行李，就正式开始了旅行。我们第一站是南京大屠杀遇难者纪念馆。当时说大屠杀纪念馆还被嘉嘉指正哈哈啊，应该叫 大屠杀遇难者同胞 纪念馆。 三 清明节的第一天就来到了大屠杀遇难者纪念馆，淅淅沥沥的雨也阻挡不了游客的热情，排队一公里应该是有了，人山人海。在门口卖菊花的游客络绎不绝，花贩子脸上的笑容和眼前的景象格格不入。整个纪念馆呈现的暗黑色，门口的雕像上还未滑下的雨水和此时的时节又完美契合。 纪念馆我们还是没有进去。只是逛了逛附近的建筑。四 浑身湿透加上大雨，第一天的行程就这样结束了，我们打道回府，准备休息，第二天早起。 晚饭？当然没吃，想不到南京第一餐就是外卖哈哈哈哈，不过真的超级好吃！赞一句南京的咸水鸭。 五 晚上在民宿也是非常开心的，没有大人们的约束，五个大学生一起聊天娱乐，这种感觉应该是我19年的过去从来没有体会过的。 第二天早早的起来了，第一站-鸡鸣寺，原来没听说过这个寺庙，不过听说在玄武湖附近，就过去啦。门票很便宜，10元一张还送三根香。往上走，里面有很多求缘分求保佑的。 寺庙最繁华的地方，有一个非常大的鼎，里面插满了香，看来在这里求保佑的人很多啊。我们也一起许了愿望插了进去。也算是一种祈福吧。 然后就去了附近的玄武湖公园。公园不大，外围是城墙，嘉嘉说这和西安很像，嗯，喜欢这种感觉。我也曾经去过济南的大明湖，不能划船，只是一个大船载满了游客到处逛，真的无聊。不过玄武湖能划船！！没错！！！不过也不是自己划船，那船是电动的，骡子子前面掌舵，我们在后面唱歌，哈哈哈哈哈啊整个湖面上的船都在看我们哈哈哈啊哈真好玩。 哦，突然忘记说了！南京最著名的景点+小吃，鸡鸣汤包！我们早晨九点半到的，然而还是人山人海。等了差不多四十分钟，终于可以吃饭了。我们点的两份鸡汁汤包一份蟹黄汤包一份香菇汤包，还有鸭血粉丝汤。写到这我真的饿了。南京灌汤包真的名不虚传，咬一口汤汁全都出来惹！卧槽，妙不可言，真的妙不可言，你懂我意思吧！ 第三站，南京大学，呵，旁边的王鹏还问我南京大学厉害还是青岛大学厉害。 不得不说，人家南大不愧985，和青岛大学就是不一样哈哈哈哈进去都感觉有一种严肃的气氛。鼓楼校区应该是老校区，里面有很多古老的楼房。不过那些外表很古老的楼房都被内部装修了，很豪华很漂亮，南大，很美。想去，很难。 未完···]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序竞赛常用技巧]]></title>
    <url>%2F2018%2F03%2F31%2Fc-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[常用技巧①读取一整行12345678910#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string.h&gt; using namespace std;int main()&#123; string str; getline(cin, str); cout &lt;&lt; str &lt;&lt; endl;&#125; getline(cin, 字符串名称);getline获取一整行数据，遇到 ‘\n’ 停止读取 ②map头文件声明： 1#include &lt;map&gt; 声明 map 与 输出123456789101112/*map*/ map&lt;string, int&gt; m; map&lt;string, int&gt;::iterator m_it; m.insert(map&lt;string, int&gt;::value_type("Wzy", 43)); m.insert(map&lt;string, int&gt;::value_type("Wjj", 2)); m.insert(pair&lt;string, int&gt;("JR", 44)); m.insert(pair&lt;string, int&gt;("LXE", 134)); for (m_it = m.begin(); m_it != m.end(); m_it++) &#123; cout &lt;&lt; m_it-&gt;first &lt;&lt; " " &lt;&lt; m_it-&gt;second &lt;&lt; endl; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开学总结]]></title>
    <url>%2F2018%2F03%2F31%2F%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[3.5号开学了， 我又来到了熟悉的课堂熟悉的宿舍，不过这一次我是以不同的心情不同的态度来看待青岛大学的，上学期，逃课弹琴，玩乐队。我不得不承认上学期我过的也很充实，我感受到了什么才是大学生活。但是我毕竟大二了，面对自己的专业课，只有自己知道自己的水平和自己脆弱的自尊心。于是，我下定决心改变！ 这学期我不想再去逃课：计算机操作系统，数据库概论以及英语口语，这些课程都非常重要，我不想在快期末的时候像一条狗一样到处求人考试坐大佬旁边然后低分飘过。 早起：这学期比上学期真的好多了，以后还是要七点左右起床，其实，一天的时间真的很充足，只不过他在你的指缝间溜走了，而你却不知道！ 面对自己曾经害怕的：反正这个博客也没人看，我就把话都说出来把。数据库和编程竞赛一直实我的软肋，为什么这个说呢？因为这些东西都是我曾经想学但是学不会的东西，或者说没有上心的东西，尤其是编程竞赛。这段时间问了问柳婼小姐姐关于程序竞赛的问题，她给我说了很多方法，在此处我记录下来： ① 明白自己为什么害怕，效率低？是因为什么？因为有思路不会写还是没思路还是有思路但是写的不够好？所以，再刷题之前，还是得把 C++ 基础打好，不然有思路写不出来程序也是竹篮打水一场空② 在学 C++ 的同时更要兼顾 STL， 这样做题的时候才会游刃有余③ 享受 AC 题目的快感，真的，我真的觉得这一点特别重要。任何事情感觉有回报才是最爽的。④ 题外话：打好计算机基础，计算机网络，计算机组成原理，计算机操作系统一定要学好⑤ 多看别人的博客，特别是优质的博客。也算是悟出来一个道理，做任何事情都不应该去逃避他，反而，面对他，打败他或许你会有不一样的收获！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study]]></title>
    <url>%2F2018%2F03%2F06%2FAndroid-Study%2F</url>
    <content type="text"><![CDATA[基础知识ToastToast是通知用户时经常用的一种方法，主要用法如下 1Toast.makeText(v.getContext(), "用户名或密码不正确", Toast.LENGTH_SHORT).show(); 或者 1Toast.makeText(MainActivity.this, "用户名或密码不正确", Toast.LENGTH_SHORT).show(); 第一个参数：联系上下文；有两种写法，第一种是v.getContext()获取上下文；第二种是MainActicity.this获取上下文。第二个参数：提示用户的语句第三个参数：响应时间的长短最后别忘了使用show()方法展示Toast。 IntentIntent：意图，用于activity的转换 123Intent i = new Intent();i.setClass(MainActivity.this, Main2Activity.class);startActivity(i); 或者 123Intent i = new Intent();i.setClass(MainActivity.this, Main2Activity.class);startActivity(i); 使用Intent传输数据 123Intent intent = new Intent(MainActivity.this, Main2Activity.class);intent.putExtra("key", 123);startActivity(intent); 在转入界面： 123Intent intent_2 = getIntent();String data = intent_2.getStringExtra("key");Log.i("Key", data); Handler12345678910111213141516171819202122232425262728293031323334353637383940414243public class Main3Activity extends AppCompatActivity &#123; private Button startButton, endButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); startButton = (Button) findViewById(R.id.startButton); endButton = (Button) findViewById(R.id.endButton); startButton.setOnClickListener(new startButtonListener()); endButton.setOnClickListener(new endButtonListener()); &#125; class startButtonListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; handler.post(updateThread); &#125; &#125; class endButtonListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; handler.removeCallbacks(updateThread); &#125; &#125; Handler handler = new Handler(); Runnable updateThread = new Runnable() &#123; @Override public void run() &#123; System.out.printf("update"); Log.i("do?","update"); handler.postDelayed(updateThread, 3000); &#125; &#125;;&#125; 类似于队列，每次调用handler就使消息发出，通过线程调用run方法。异步线程处理方案 什么是 SharedPreferencesSharedPreferences，说到底就是一个存储机制。但是不像 SQLite 那样存储大容量大数据，适合存储可以用键值对表达的小数据，例如账号和密码(但是密码要进行加密处理) 如何使用 SharedPreferences例如实现记住密码功能：需要存储两个数据，一个 account，一个 password，将其以键值对的形式储存起来。 首先创建一个 SharedPreferences 对象和一个 SharedPreferences.edit 分别用来读取数据和写入数据 12private SharedPreferences sharedPreferences;private SharedPreferences.Editor editor; sharedPreferences 用来读取数据，editor 用来写入数据 12sharedPreferences=getSharedPreferences("import",MODE_PRIVATE);editor =getSharedPreferences("import",MODE_PRIVATE).edit(); 123editor.putString("ac", x);editor.putString("pw", y);editor.apply(); 就这样以键值对的形式存储数据 读取数据只需要得到响应的 key 就可以: 12345String a = sharedPreferences.getString("ac", "123");String b = sharedPreferences.getString("pw", "123");username.setText(a);password.setText(b); ADB 简介ADB 全称为 android debug brdge, 简单来说就是安卓调试桥，目前我这个程度用的是查询安卓内置数据库 使用 adb 查询 sqlite 数据库① 首先启动 adv， 以管理员身份级进入 cmd，输入 adb shell进入 ② 转到 app 数据库所在位置如果出现类似 permission definde，就说明你无法访问数据库，API 设置的权限，目前 API 17 可以访问 ③ 输入 ls 可以查询当前目录的文件 ④ 进入数据库：进入 personManger 数据库，sqlite3 + 数据库名称即可 ⑤ 输入简单的命令测试是否成功进入输入 .table 即可查看数据库中的表 ⑥ 查询数据库切记：一定要加上分号 ⑦ 退出.exit]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于考研]]></title>
    <url>%2F2018%2F02%2F24%2F%E5%85%B3%E4%BA%8E%E8%80%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[今天逛微博无意中发现了北理工一名老师关于考研的言论 123有不少高考失利去了不理想学校的学生，很早(甚至从大一大二)就开始准备考研。其奋斗的精神值得鼓励，但具体方法方式则欠妥，因为这本质上是将考研等同于二次高考，一考定终身，但实际上考研有初试也有复试，时不时会出现初试高分考生复试被刷，或者不被牛导师青睐的事情。排除潜规则的影响，多数都是学生以高考的心态与方式应对考研，考研课目的内容是很熟练了，但专业必备基础知识与技能则往往比较欠缺，毕竟一个人的时间精力有限，做了这事就干不了那事，这种学生，往往既搞不了科研，又做不了工程项目，不受欢迎与接受……比较好的方式是大一大二大三，别只盯着考研，而是认真地学习专业知识，培养专业技能，努力找机会参与科研或工程实践，到大四才针对考研进行专门的应试训练和准备。把本科上成了四年考研班，其实是在考试这件事上过度训练了，并不划算。 我觉得说的非常有道理，如果把大学四年上成了考研班，然后初试高分，复试低分，又有什么意义，工程在于实践，理论知识基础！下面是我摘录的金老师的其他言论，感觉讲的非常有道理 1234567891011我通常认为一个人应该“志存高远”，同时要“脚踏实地”。具体到计算机专业的学生，我通常建议他们大学四年应该重点干好两个大事：（1）努力学好各种专业理论。为自己能从事高精尖的技术研发与科学探索的工作打好基础，为进一步深造做好准备，……（2）学习与掌握各种实用技能。前面高大上的目标达不到（比如进名校深造，到业界一流企业工作），至少也能具备在业界普通公司混口饭的能力，不至于当个啃老族……这两者其实并不矛盾，而是相互促进的，把握好其中的度，对一个人四年大学收获的多少有着巨大的影响，这通常也是区分优秀与普通学生的分水岭。那些两者都做不到的，就把人生中最宝贵的四年给浪费了，非常可惜，他们毕业工作几年之后，通常都会感叹当年在学校时——为什么不懂和不做这些事，如果当年做了，现在的发展又岂止步于此？ 大学四年，掌握最基本的能力，脚踏实地的同时怀揣梦想，那么大学一定是成功的！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018上半年学习计划]]></title>
    <url>%2F2018%2F02%2F12%2F2018-2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[未来的这两年，不会再涉及新的语言，主要就是Java和Python。C++的学习主要是考研和数据结构的学习 2018上半年 😁这半年主要就是夯实英语基础。 早睡早期一定要做到！！！！ 其实我觉得百词斩对我这种短时间记忆力很强但是长时间记忆力很弱的人一点用处都没有 我觉得既然是应试，那就按照应试来，下半年准备英语的正式复习，主要是从背单词和做四六级题目开始。 这半年也应该加强数据结构的学习，为明年更多的时间复习数学打下基础，掌握一些C++的基本语法就可以，不必深究面向对象的一系列知识，下半年抽空刷题，准备大三的PAT和蓝桥杯。 还有就是Java和Python数据分析的进一步深入，进度我不是很在乎了，能有自己的小项目就行 总的来说：２０１８上半年主要就是英语和程序设计 2018下半年 😃关于下半年的开始，我觉得暑假开始的时候就应该是下半年了，下半年的任务就比较重了 emmmmmm，现在说也有点太早了，等到了那个时候，再制定计划吧，加油！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS入门]]></title>
    <url>%2F2018%2F02%2F11%2FDFS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[题意：n件物品，每件物品重量为w[i]，价值为c[i]，背包的最大承重为v，在不超过重量v的前提下，让背包中，物品的价格之和最大，求最大价值！在面对每一个选择的时候，可以选择，也可以不选择，dfs之后得出来的结果一定是最大值，dfs其实就是暴力搜索 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int max_value = 0, n, v, w[101], c[101]; void dfs(int index, int sumW, int sumC);void dfs(int index, int sumW, int sumC)&#123; if(index == n) &#123; if(sumW &lt;= v &amp;&amp; sumC &gt; max_value) &#123; max_value = sumC; &#125; return; &#125; else &#123; dfs(index + 1, sumW, sumC); dfs(index + 1, sumW + w[index], sumC + c[index]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n, &amp;v); for(int i = 0; i &lt; n; i++) &#123; scanf("%d%d",&amp;w[i], &amp;c[i]); &#125; dfs(0, 0, 0); printf("%d\n",max_value);&#125; 优化算法： 12345678910111213141516void dfs(int index, int sumW, int sumC)&#123; if(index == n) &#123; return; &#125; dfs(index + 1, sumW, sumC); if(sumW + w[index] &lt;= v) &#123; if(sumC + c[index] &gt; max_value) &#123; max_value = sumC + c[index]; &#125; dfs(index + 1, sumW + w[index], sumC + c[index]); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-正则表达式]]></title>
    <url>%2F2018%2F02%2F02%2FPython%E7%88%AC%E8%99%AB-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。 正则表达式基本使用 基本使用规则前提：导入 re 包re库采用raw string类型来表示正则表达式比如r’text’ Re库主要功能函数 re.search()：在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 1234import rematch = re.search(r'[1-9]\d&#123;5&#125;','BIT 100081')if match: print(match.group(0)) 123import rex = re.sub(r'[1-9]\d&#123;5&#125;','我爱吴嘉婕','BIT123456FEEG123456')print(x) BIT我爱吴嘉婕FEEG我爱吴嘉婕 match对象1.match.string:返回匹配的字符串是什么 123import rex = re.search(r'[1-9]\d&#123;5&#125;','BIT123456FEEG123456')print(x.string) match.re: 返回正则表达式 match.start()：符合匹配的初始位置 match.end()：符合匹配的结束位置 match.end(): 返回一个元组：包括起始位置和结束位置返回的就是BIT123456FEEG123456]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫实战]]></title>
    <url>%2F2018%2F01%2F31%2FPython-%E2%80%9C%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[爬取大学排名1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return '出错啦'def fillUnivList(ulist,html): soup = BeautifulSoup(html,'html.parser') for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string,tds[1].string,tds[2].string])def printUnivList(ulist,num): tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名","大学名称","总分",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2],chr(12288)))def main(): uinfo = [] url = 'http://www.zuihaodaxue.com/shengyuanzhiliangpaiming2017.html' html = getHTMLText(url) fillUnivList(uinfo,html) printUnivList(uinfo,30)main() 爬取淘宝网商品信息1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport redef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ''def parsePage(ilt,html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price,title]) except: print('出错啦')def printGoodList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:15&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count += 1 print(tplt.format(count,g[0],g[1]))if __name__ == '__main__': goods = '耳机' deepth = 5 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(deepth): try: utl = start_url + '&amp;s=' + str(44*i) html = getHTMLText(start_url) parsePage(infoList, html) except: continue printGoodList(infoList) 爬取当当网信息代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsimport redef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: print('错误1')def pareHTML(html): try: book_price = re.findall(r'&amp;yen;(.*?)&lt;', html) book_name = re.findall(r'&lt;a title="(.*?)"', html) printHTMLMessage(book_price, book_name) # for i in range(len(list1)): # # price = eval(book_price[i].split(':')[1]) # # print(price) # # title = eval(book_name[i].split(':')[1]) # # print(title) # list1.append([book_price[i],book_name][i]) # print(list1) except: print('错误2')def printHTMLMessage(price, name): muban = "&#123;:1&#125;\t\t&#123;:6&#125;\t&#123;:15&#125;" print(muban.format('序号', '价格', '书名')) count = 1 for i in range(len(name)): print(muban.format(count, price[i], name[i])) count += 1if __name__ == '__main__': goods = input("请输入您要查询得商品：") deepth = (input("请输入查询的页数：")) list1 = [] for i in range(1, deepth + 1): try: url = 'http://search.dangdang.com/?key=' + goods + '&amp;act=input&amp;page_index=' + str(i) html = getHTMLText(url) pareHTML(html) except: continue]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫入门]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E7%88%AC%E8%99%AB%E2%91%A0%2F</url>
    <content type="text"><![CDATA[requestsPython Request库入门 requests的安装requests库是Python第三方库最强大的爬虫库以管理员身份运行cmd，输入pip install requests即可，然后运行pycharm导入随便写一个Python程序 123456import requestsr = requests.get("http://www.baidu.com")print(r.status_code)print(type(r))r.encoding = 'utf-8'print(r.text) raise_for_status()方法调用raise_for_status()方法，如果r.status_code的返回值是200，则程序正常执行，如果不是两百，那么就会抛出一个requests.HTTPError异常 常用代码框架1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "产生异常"if __name__ == "__main__": url = "https://www.icourse163.org" print(getHTMLText(url)) HTTPhttp协议：超文本传输协议，是一个基于响应与请求模式的无状态的应用层协议请求与响应：用户发出请求，服务器响应 计算多次连续访问同一页面所需要的时间123456789101112def main(): url = 'https://www.icourse163.org/learn/BIT-1001870001?tid=1002236011#/learn/content?type=detail&amp;id=1002993601&amp;cid=1003503362' n = (int)(input("请输入需要爬取页面的次数： ")) t1 = time.time() for i in range(1,n+1): getHTMLText(url) print('第%d次爬取成功'%i) t2 = time.time() t = t2 - t1 print('连续访问%d个页面需要的时间是%f秒'% (n,t))main() 模拟浏览器发出请求12345678910import requestsurl = 'https://www.amazon.cn/gp/product/B0058XHR28?pf_rd_p=8e368709-9a2f-4695-abee-10147fab0c6e&amp;pf_rd_s=merchandised-search-7&amp;pf_rd_t=101&amp;pf_rd_i=1841388071&amp;pf_rd_m=A1AJ19PSB66TGU&amp;pf_rd_r=JKH9RF6AFN0YGT4GY92N&amp;ref=cn_ags_floor_hotasin_1841388071_mobile-1'try: kv = &#123;'User-Agent':'Mozilla/5.0'&#125; r = requests.get(url,timeout = 10,headers = kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.request.headers)except: print('失败') 通过修改头部信息，从而模拟浏览器访问页面 百度关键词搜索1234567891011import requestskv = &#123;'wd':'python'&#125;try: r = requests.get('https://www.baidu.com/s',params = kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.request.url) print(len(r.text))except: print('爬取失败') 从网上爬取图片并下载下来不规范版本： 1234567import requestspath = "D:/abc.jpg"url = 'http://imgsrc.baidu.com/forum/pic/item/e420a54bd11373f027775715a40f4bfbfaed0456.jpg'r = requests.get(url)# print(r.status_code)with open(path,'wb') as f: f.write(r.content) 规范： 1234567891011121314import requeststry: #图片地址 url = 'http://imgsrc.baidu.com/forum/pic/item/e420a54bd11373f027775715a40f4bfbfaed0456.jpg' #根目录 root = 'D:/' #储存的路径 path = root + url.split('/')[-1] r = requests.get(url) with open(path,'wb') as f: f.write(r.content)except: print("出错啦") ip地址查询123456789import requeststry: url = 'http://m.ip138.com/ip.asp?ip=' r =requests.get(url + '202.204.80.112') print(r.text[-500:])except: print("出错啦") 下载一个MOOC的视频123456789101112#爬一个慕课网的视频import requeststry: url = 'https://v.stu.126.net/mooc-video/nos/mp4/2017/02/28/1005855330_c19061df10ee4cd69496dba4292e9ea3_shd.mp4?ak=285ea3e4dadf82f0450503b24518d5679cdf68ccbb7c2011693b179b27153140698691431388c23472d118fc0d79340ceff6a55d15491982836e42383e13363eec6958477c8e90f2fc976eed060cb9b81e46d140b7b30f910299bee40b26a5c2d9e1e3c44585e5de5b539ccdbe8423a821b91261e44e538d2765af73aa008299a7f5cc498d43fe59a782bc973c30c066b767da1f870bc890754ea6567cb70ca9830b67d08aac63e1ac0c534090a89323f6fd9d4e9030d5d8cb0cb4b5fcb8e77c' r = requests.get(url) path = 'D:/123.mp4' with open(path,'wb') as f: f.write(r.content) print("下载完毕")except: print("XXX") BeautifulSoup库的使用安装以管理员身份运行cmd，输入pip install BeautifunSoup4,然后在pycharm导入相应的模块就可以了 运行代码123456from bs4 import BeautifulSoupimport requestsr = requests.get("http://jw.qdu.edu.cn/homepage/index.do")demo = r.textsoup = BeautifulSoup(demo,"html.parser")print(soup.prettify()) soup = BeautifulSoup(demo,”html.parser”)的两个参数：第一个参数是html的一个格式第二个参数是html的解析器 基本元素BeautifulSoup库是解析，遍历，维护标签树的功能库 1.Tag2.Name3.Attributes4.Comment5.NavigableString 获得标签信息12345678#获得a标签tag = soup.a#获得a的名字，当然就是aprint（soup.a.name）#获得标签属性print（soup.a.attrs）#获得标签之间的字符串print(soup.a.string) .prettify()能够更加有好的显示html文件，包括换行符缩进等等 查找一个HTML页面a标签href后的内容12345678910from bs4 import BeautifulSoupimport requestsr = requests.get("https://www.icourse163.org/learn/BIT-1001870001?tid=1002236011")demo = r.textsoup = BeautifulSoup(demo,"html.parser")for link in soup.find_all('a'): if link.get('href') == None: pass else: print(link.get('href'))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2018%2F01%2F29%2FPython%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Python中的异常处理常见形式123456789101112131415try: #文件错误 f = open('abc.txt') print(f) f.close() #数值错误 int('abc') #类型错误 sum = 1 + '1'except OSError as reason: print(reason)except TypeError as reason: print(reason)except ValueError as reason: print(reason) 当然也可以使用多个异常在一条语句： 1234567891011try: #文件错误 f = open('abc.txt') print(f) f.close() #数值错误 int('abc') #类型错误 sum = 1 + '1'except (OSError,TypeError) as reason: print(reason) finally语句和Java一样，finally语句是无论如何都要执行的语句： 1234567try: #文件错误 f = open('abc.txt','w')except OSError as reason: print(str(reason))finally: f.close() raise关键字raise和Java中的throws关键字一样，都是抛出一个异常的意思 1raise ZeroDivisionError('除数为0') With关键字12345678try: f = open('我是谁.txt','w') for each_line in f: print(each_line)except OSError as reason: print(reason)finally: f.close() 如果文件不存在会创建一个”我是谁.txt”文件，但是会抛出一个noreadable异常关闭文件的时候只会关闭一个不存在的文件。这时候就可以使用with关键字监视文件f，会自动关闭文件 123456try: with open('我是谁.txt','w') as f: for each_line in f: print(each_line)except OSError as reason: print(reason) with关键字常用于文件的操作 类和对象视频出处类和变量 类的创建和类的实例化一般来说，类名都是大写 12345678910111213class Dog: #属性 color = 'green' weight = '10' def climb(self): print('小狗跳啊跳')#实例化对象a_dog = Dog()#调用方法a_dog.climb() self是什么类似于C++的this指针 123class Ball: def setName(self,name): self.name = name self在类中的方法中是必须的！ 类的继承1234567891011class MyList(list): pass list2 = MyList()list2.append(9)list2.append(1)list2.append(88)list2.sort()print(list2) 多态12345678910class A: def fun(self): print('我是A')class B: def fun(self): print('我是B')a = A()b = B()a.fun()b.fun() 类的构造方法12def __init__(self): print('') 和Java不一样的是，以下代码会报错 1234class Ball: def __init__(self,name): print('')a = Ball() 因为没有穿进去name参数，而Python不会新建一个无参构造器 公有和私有将类中的属性变为私有只需要在前面加上__即可1234class Person(): __name = '小甲鱼'p = Person()print(p.__name) 由于__name是私有属性，类的外部无法访问,编译出错1234Traceback (most recent call last): File "D:/大二学习资料/Python/HelloWorld.py", line 95, in &lt;module&gt; print(p.__name)AttributeError: 'Person' object has no attribute '__name' 可以通过以下代码访问123456class Person(): __name = '小甲鱼' def getname(self): return self.__namep = Person()print(p.getname()) 但是Python的私有机制是“伪私有”，实际上就是Pyton将变量名改成了_类名__变量名通过一下代码就可以访问私有变量123456class Person(): __name = '小甲鱼' def getname(self): return self.__namep = Person()print(p._Person__name) 特性Python不支持函数重载。 构造函数构造函数没有任何返回，也就是返回的是一个None new 的作用依照Python官方文档的说法，new方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。 假如我们需要一个永远都是正数的整数类型，通过集成int，我们可能会写出这样的代码。123456789class PositiveInteger(int): def __init__(self, value): super(PositiveInteger, self).__init__(self, abs(value))i = PositiveInteger(-3)print i 但运行后会发现，结果根本不是我们想的那样，我们任然得到了-3。这是因为对于int这种 不可变的对象，我们只有重载它的new方法才能起到自定义的作用。1234567891011这是修改后的代码：class PositiveInteger(int): def __new__(cls, value): return super(PositiveInteger, cls).__new__(cls, abs(value))i = PositiveInteger(-3)print i 通过重载new方法，我们实现了需要的功能。 del 的作用垃圾回收机制，当类的所有对象都delte之后，启用del方法 123456789class A: def __init__(self): print("I am __init__") def __del__(self): print("I am del")a = A()b = A()c = A() 运行结果123456I am __init__I am __init__I am __init__I am delI am delI am del]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中string字符串的比较]]></title>
    <url>%2F2018%2F01%2F28%2FC-%E4%B8%ADstring%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[🙂通过C++内置的sort加上自定义cmp函数可以实现string字符串的比较，因为C++string重载了一些运算符，可以直接比较大小。可以多重定义cmp函数！123456789bool cmp(char a,char b)&#123; return a &gt; b;&#125;bool cmp1(string a,string b)&#123; return a &gt; b;&#125; cin，coutC++涉及string一定要用到cin，cout输入和输出其包含在 #include头文件中 1cout &lt;&lt; endl 代表换行 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std;bool cmp(char a,char b)&#123; return a &gt; b;&#125;bool cmp1(string a,string b)&#123; return a &gt; b;&#125;int main()&#123; string s1 = "4321"; sort(s1.begin(),s1.end()); cout &lt;&lt; s1 &lt;&lt; endl; sort(s1.begin(),s1.end(),cmp); cout &lt;&lt; s1 &lt;&lt;endl; string s[3]; s[0] = "123"; s[1] = "234"; s[2] = "211"; sort(s,s+3); for(int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; s[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; sort(s,s+3,cmp1); for(int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; s[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;/*12344321123 211 234234 211 123*/]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2018%2F01%2F28%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 二分查找代码就不解释了，很简单123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int x; scanf("%d",&amp;x); int mid,left,right; int a[20] = &#123;1,2,3,4,5,6,7,8,10,15,79&#125;; left = 0; right = 10; while(left &lt;= right) &#123; mid = (left + right)/2; if(x == a[mid]) &#123; printf("%d",mid+1); break; &#125; else if(a[mid] &gt; x) &#123; right = mid - 1; &#125; else if(a[mid] &lt; x) &#123; left = mid + 1; &#125; else &#123; printf("没找到此数"); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更新博客基本步骤]]></title>
    <url>%2F2018%2F01%2F28%2FHexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作 新建文章1$ hexo new &quot;文章名&quot; 更新操作12$ hexo g$ hexo d 或者1$ hexo d -g 添加tags或者categories直接在md文件里添加即可，不必新建一个tags或者categories]]></content>
      <categories>
        <category>Hexo学习</category>
      </categories>
      <tags>
        <tag>Hexo学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间贪心算法]]></title>
    <url>%2F2018%2F01%2F27%2F%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[找出有限集合中，不重合区间的最大的个数 算法将得到的区间按照区间右端点从小到小排序，然后从第一组开始，一次判断是否符合条件，若符合，count++，最后输出count即可，仍需注意，如果count如果从1开始计数，排序后的数组应该从第二个开始对应。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x; int y;&#125;I[1000];bool cmp(node a,node b)&#123; if(a.y != b.y) &#123; return a.y &lt; b.y; &#125;&#125;int main()&#123; //区间个数 int count = 1; int n; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d %d",&amp;I[i].x,&amp;I[i].y); &#125; sort(I+1,I+n+1,cmp); for(int i = 2; i &lt;= n; i++) &#123; if(I[i].x &lt; I[i-1].y) &#123; &#125; else &#123; count++; &#125; &#125; printf("%d",count); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclpise快捷键]]></title>
    <url>%2F2017%2F11%2F12%2FEclpise%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。Eclipse 常用快捷键Eclipse 的很多操作都提供了快捷键功能，我们可以通过键盘就能很好的控制 Eclipse 各个功能： 使用快捷键关联菜单或菜单项使用快捷键关联对话窗口或视图或编辑器使用快捷键关联工具条上的功能按钮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Ctrl+1 快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如import类、try catch包围等）Ctrl+Shift+F 格式化当前代码Ctrl+Shift+M 添加类的import导入Ctrl+Shift+O 组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用）Ctrl+Y 重做（与撤销Ctrl+Z相反）Alt+/ 内容辅助（帮你省了多少次键盘敲打，太常用了）Ctrl+D 删除当前行或者多行Alt+↓ 当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了）Alt+↑ 当前行和上面一行交互位置（同上）Ctrl+Alt+↓ 复制当前行到下一行（复制增加）Ctrl+Alt+↑ 复制当前行到上一行（复制增加）Shift+Enter 在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）Ctrl+/ 注释当前行,再按则取消注释选择Alt+Shift+↑ 选择封装元素Alt+Shift+← 选择上一个元素Alt+Shift+→ 选择下一个元素Shift+← 从光标处开始往左选择字符Shift+→ 从光标处开始往右选择字符Ctrl+Shift+← 选中光标左边的单词Ctrl+Shift+→ 选中光标又边的单词移动Ctrl+← 光标移到左边单词的开头，相当于vim的bCtrl+→ 光标移到右边单词的末尾，相当于vim的e搜索Ctrl+K 参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word）Ctrl+Shift+K 参照选中的Word快速定位到上一个Ctrl+J 正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建）Ctrl+Shift+J 反向增量查找（和上条相同,只不过是从后往前查）Ctrl+Shift+U 列出所有包含字符串的行Ctrl+H 打开搜索对话框Ctrl+G 工作区中的声明Ctrl+Shift+G 工作区中的引用导航Ctrl+Shift+T 搜索类（包括工程和关联的第三jar包）Ctrl+Shift+R 搜索工程中的文件Ctrl+E 快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）F4 打开类型层次结构F3 跳转到声明处Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面（当然是针对上面那条来说了）Ctrl+PageUp/PageDown 在编辑器中，切换已经打开的文件调试F5 单步跳入F6 单步跳过F7 单步返回F8 继续Ctrl+Shift+D 显示变量的值Ctrl+Shift+B 在当前行设置或者去掉断点Ctrl+R 运行至行(超好用，可以节省好多的断点)重构（一般重构的快捷键都是Alt+Shift开头的了）Alt+Shift+R 重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力）Alt+Shift+M 把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）Alt+Shift+C 修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定）Alt+Shift+L 抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）Alt+Shift+F 把Class中的local变量变为field变量 （比较实用的功能）Alt+Shift+I 合并变量（可能这样说有点不妥Inline）Alt+Shift+V 移动函数和变量（不怎么常用）Alt+Shift+Z 重构的后悔药（Undo）其他Alt+Enter 显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径Ctrl+↑ 文本编辑器 上滚行Ctrl+↓ 文本编辑器 下滚行Ctrl+M 最大化当前的Edit或View （再按则反之）Ctrl+O 快速显示 OutLine（不开Outline窗口的同学，这个快捷键是必不可少的）Ctrl+T 快速显示当前类的继承结构Ctrl+W 关闭当前Editer（windows下关闭打开的对话框也是这个，还有qq、旺旺、浏览器等都是）Ctrl+L 文本编辑器 转至行F2 显示工具提示描述]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2017%2F11%2F08%2FGit-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[概念，git，解决版本控制的问题的操作体系，基本形式是分布式 概念，提交，一个保存的工作状态，整个git的基本元素，类似于还原点的作用，可以查到版本号 概念，工作区，暂存区，master分支，head指针。基本是工作区和版本库，版本库包含暂存区和提交区（分支区），工作区是工作文件夹，暂存区是作为提交缓存以及确保不会提交错用的，master是默认的分支，head指针指向当前分支。指针结果类似c++。所有看起来复杂的操作，背后的逻辑都是这4个概念 技巧，status查看状态时会给出操作提示 概念，分支，本质是一种提交, 准确来说应该是提交区，基于分支概念，修复bug开发feature的时候都应该应用这种手段。另一方面，基于分支概念，开发的基本模式，master稳定发布版本，dev提交开发版，其他另开支线 git本质上是用于版本控制，准确的讲，分布式版本控制管理系统 分布式：每台机器都又独立的资源，有一个总服务器强调用于资源交换更新 集中式：资源都处于一个服务器中，每台机器连接后操作 创建版本库123456$ mkdir learngit 创建文件夹$ cd learngit 进入$ pwd 查看目录$ git init 初始化为版本库$ git add readme.txt 添加的暂存区$ git commit -m &quot;wrote a readme file&quot; 提交 时光穿梭基本操作12$ git status 查看状态（工作区和暂存区）$ git diff 查看修改（对比工作区和提交中） 版本回退123456$ git log 查看日志$ git reflog 查看未来日记$ git log --pretty=oneline 简化日志两种回退$ git reset --hard HEAD^ 上一个版本 ^^和~100$ git reset --hard 3628164 撤销修改123$ cat readme.txt 查看$ git checkout -- readme.txt 恢复，原理是和版本库同步$ git reset HEAD readme.txt 取消添加到暂存区 删除文件1234$ rm test.txt 文件管理器中删除$ git rm test.txt 添加删除操作到暂存区$ git commit -m &quot;remove test.txt&quot; 提交$ git checkout -- test.txt 用于取消删除，原理是和版本库同步 远程仓库概念.分支本质上一种提交,master指针和其他指针操作,方便于开发来回操作的一种体系.要注意,本质上区别于平行世界. 分支的基本Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突: 两条分支都修改merge后提示错误，只需要再进入文件，按提示修改后提交即可 文件中是这样的 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 分支管理策略：形成一套开发体系基本操作是基于合并的时候保存该分支的提交 查看分支图：git log --graph --pretty=oneline --abbrev-commit 合并保存（禁用fast forwardgit merge --no-ff -m &quot;merge with no-ff&quot; dev 遇到bug需要开发新feature：保存当前分支，切取修bug保存现场 git status 查看stash git status list 恢复现场两种 应用某一个git stash apply stash@{0},删除第一个（0）git stash drop 应用并删除git stash pop 远程相关123456789$ git remote -v 查看连接 -v为详细信息参数$ git push origin master 推送分支克隆到本地$ git clone git@github.com:michaelliao/learngit.git设置修改人和邮箱$ git config --global user.name &quot;Your Name&quot; 设置修改人 --global为全局参数$ git config --global user.email &quot;email@example.com&quot; 设置邮箱查看修改其他分支$ git checkout -b dev origin/dev 解决多人修改同一个分支的问题 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 标签本质同样是提交，和分支类似，只不过分支可以移动，标签不可以 1234567891011添加$ git tag v1.0 当前指针标签$ git tag v0.9 6224937 版本号标签$ git show v0.9 详情$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a -s用私钥签名一个标签安装gpg（GnuPG）删除$ git tag -d v0.1 本地git push origin :refs/tags/&lt;tagname&gt; 远程（需要先删本地）推送$ git push origin v1.0 推送一个$ git push origin --tags 推送全部]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[折腾了三天了，各种百度，终于终于把这个博客搭建好了，啊阿阿阿阿阿真的折腾哈哈哈，不过还是特别特别开心的 一 为什么搭建这个博客？原因有二吧，第一个是真么不喜欢CSDN和博客园，另外也觉得自己应该接触一下github和各种命令行了！ 二 自己选择选软工程这个专业也算是自己的一份执着吧，去年暑假跟家人各种信誓旦旦好好学习，但是自己还是没有做到，整个大一一年，睡觉弹琴，各种玩各种嗨，认识了很多人，专业课和一些基础课程都拉下了，也挂了科，其实也挺后悔的，或许我属于那种想变的很优秀但是却不愿意付出努力的那种人吧 三 我说过，我是一个想变的优秀但是不愿意改变的人，今年六月份，学校的实验室开始纳新了，当时我觉得那是一个改变现状的好机会，于是我努力了两个月，把C语言一通学，各种刷题，然后磕磕绊绊进了我们院的俩实验室，再后来误打误撞考进了我们学校的ACM集训队，暑假回家一个周，剩下的时间都在实验室泡着，天天刷题，说实话，我不是很聪明的那种人，集训的那两个月，我真的特别特别痛苦，想女朋友，想家人，每天面对形形色色的题，真的有一种绝望的感觉，知道那天晚上我明白了，或许我不适合程序竞赛吧！ 四 虽然说在集训队的这两个月我很痛苦，但是很充实，也和我们学校很多优秀的人一起学习，当时非常迷茫，现在只能说是比较迷茫吧哈哈哈哈，但是，知道我对未来有了目标，大二了，我感觉到了，我确实变化了，但是还不够，我希望自己变的更优秀！加油吧！ 五嗯，不说了，希望自己能用博客记录自己的编程之路！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
